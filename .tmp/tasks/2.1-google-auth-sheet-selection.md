# Task 2.1: Google認証・シート選択機能実装

**タスクID**: 2.1
**タスク名**: Google認証・シート選択機能実装
**依存**: Task 1.3 (D1データベース基盤)
**推定時間**: 9時間

## 概要

初期設定画面でGoogle OAuth2認証を実装し、ユーザーがGoogle Sheetsを選択できる機能を提供します。Google認証情報（Client ID、Client Secret、Redirect URI）はフォーム入力で設定し、選択されたシート情報と共にD1のconfigテーブルに保存されます。

## 技術スタック

- **認証**: Google OAuth 2.0
- **UI**: Hono JSX (SSR)
- **API**: Hono (Cloudflare Workers)
- **データベース**: D1 (Drizzle ORM)
- **設定管理**: D1 configテーブル（Google認証情報含む）

## 実装範囲

### 1. Google OAuth2設定フォーム

#### 設定入力UI
```typescript
// Google認証情報入力フォーム
interface GoogleAuthConfig {
  clientId: string;        // Google Cloud ConsoleのOAuth 2.0クライアントID
  clientSecret: string;    // クライアントシークレット
  redirectUri: string;     // リダイレクトURI (例: https://your-app.workers.dev/api/setup/google-callback)
}
```

**入力項目:**
1. **Google Client ID** - OAuth 2.0クライアントID
2. **Google Client Secret** - クライアントシークレット（暗号化して保存）
3. **Redirect URI** - OAuth認証後のリダイレクト先（自動生成も可能）

**保存先:**
- D1 configテーブルの以下のキー
  - `google_client_id`
  - `google_client_secret` (暗号化)
  - `google_redirect_uri`

### 2. 初期設定画面UI実装

#### コンポーネント構造
```typescript
// src/components/Setup.tsx
/**
 * Initial setup page component
 *
 * Setup Flow:
 * 1. Google認証情報入力フォーム (Client ID, Secret, Redirect URI)
 * 2. 認証情報保存
 * 3. Google OAuth2認証フロー開始
 * 4. シート選択
 * 5. 設定完了
 */
export const Setup: FC = () => {
  // Implementation: Multi-step setup wizard
};
```

#### 画面構成（ステップバイステップ）

**Step 1: Google認証情報設定**
- Google Client ID 入力フィールド
- Google Client Secret 入力フィールド（password type）
- Redirect URI 入力フィールド（デフォルト値自動設定可能）
- 「認証情報を保存してGoogleに接続」ボタン
- Google Cloud Consoleへのリンク（設定方法ガイド）

**Step 2: シート選択**（OAuth2コールバック成功後に自動遷移）
- シート選択ドロップダウン
- 「次へ」ボタン

**Step 2.5: シート初期化**（シート選択後、自動的に実行）
- プログレスインジケーター表示
- 必須シート作成処理:
  - ✓ _Usersシート作成中...
  - ✓ _Rolesシート作成中...
  - ✓ _Filesシート作成中...
- 各シートのヘッダー行設定
- 完了後、自動的にStep 3に遷移

**Step 3: ファイル保存先・初期管理者設定**
- **ファイル保存先設定**
  - ラジオボタン: Google Drive / Cloudflare R2
  - Google Drive選択時: Folder ID 入力フィールド
  - R2選択時:
    - Bucket Name 入力フィールド
    - Account ID 入力フィールド
    - Access Key ID 入力フィールド
    - Secret Access Key 入力フィールド（password type）
- **初期管理者設定**
  - 管理者ID 入力フィールド
  - 管理者パスワード 入力フィールド（password type）
  - パスワード確認 入力フィールド（password type）
- **マスターキー設定**
  - マスターキー 入力フィールド（自動生成ボタン付き）
  - マスターキー説明: "ACLをバイパスして全データにアクセスできる特殊なキーです。安全に保管してください。"
- 「設定を完了」ボタン

**共通要素**
- 進行状況インジケーター（Step 1/3, 2/3, 3/3）
- エラーメッセージ表示エリア

### 3. シート選択UI実装

```typescript
// src/components/SheetSelector.tsx
/**
 * Sheet selector component
 *
 * Features:
 * - Display available sheets from authenticated Google account
 * - Sheet selection dropdown
 */
interface SheetSelectorProps {
  sheets: Sheet[];
  onSelect: (sheetId: string) => void;
  selectedSheetId?: string;
}

export const SheetSelector: FC<SheetSelectorProps> = (props) => {
  // Implementation: Simple sheet selection dropdown
};
```

```typescript
// src/components/SheetInitializer.tsx
/**
 * Sheet initializer component with progress indicator
 *
 * Features:
 * - Display initialization progress
 * - Show step-by-step sheet creation status
 * - Handle errors during initialization
 */
interface SheetInitializerProps {
  sheetId: string;
  onComplete: () => void;
  onError: (error: string) => void;
}

export const SheetInitializer: FC<SheetInitializerProps> = (props) => {
  // Implementation:
  // 1. Call /api/setup/initialize-sheet endpoint
  // 2. Display progress indicator with status for each sheet:
  //    - ⏳ _Usersシート作成中...
  //    - ✓ _Usersシート作成完了
  //    - ⏳ _Rolesシート作成中...
  //    - ✓ _Rolesシート作成完了
  //    - ⏳ _Filesシート作成中...
  //    - ✓ _Filesシート作成完了
  // 3. On completion, call onComplete()
  // 4. On error, call onError()
};
```

### 4. Google認証情報保存エンドポイント

```typescript
// src/routes/setup.ts
import { Hono } from 'hono';
import type { Env } from '../types/env';

const setup = new Hono<{ Bindings: Env }>();

/**
 * POST /api/setup/google-config - Save Google OAuth2 credentials
 *
 * Request body:
 * {
 *   "clientId": "xxx.apps.googleusercontent.com",
 *   "clientSecret": "GOCSPX-xxx",
 *   "redirectUri": "https://your-app.workers.dev/api/setup/google-callback"
 * }
 *
 * Saves Google OAuth2 credentials to D1 config table
 */
setup.post('/google-config', async (c) => {
  // Implementation:
  // 1. Validate input (required fields, format)
  // 2. Encrypt client secret
  // 3. Save to config table:
  //    - google_client_id
  //    - google_client_secret (encrypted)
  //    - google_redirect_uri
  // 4. Return success response
});

/**
 * GET /api/setup/google-auth - Initiate Google OAuth2 flow
 *
 * Returns authorization URL for Google OAuth2
 * Requires google_client_id to be configured in config table
 *
 * CSRF Protection: Uses signed cookie approach
 */
setup.get('/google-auth', async (c) => {
  // Implementation:
  // 1. Retrieve google_client_id from config table
  //
  // 2. Generate OAuth2 state token (cryptographically random)
  // const stateToken = crypto.randomUUID(); // or use crypto.getRandomValues()
  //
  // 3. Sign state token with HMAC-SHA256 using secret key
  // const secret = c.env.OAUTH_STATE_SECRET; // from environment variable
  // const encoder = new TextEncoder();
  // const key = await crypto.subtle.importKey(
  //   'raw',
  //   encoder.encode(secret),
  //   { name: 'HMAC', hash: 'SHA-256' },
  //   false,
  //   ['sign']
  // );
  // const signature = await crypto.subtle.sign(
  //   'HMAC',
  //   key,
  //   encoder.encode(stateToken)
  // );
  // const signedState = `${stateToken}.${btoa(String.fromCharCode(...new Uint8Array(signature)))}`;
  //
  // 4. Set signed state as HttpOnly, Secure, SameSite=Lax cookie
  // c.cookie('oauth_state', signedState, {
  //   httpOnly: true,
  //   secure: true,
  //   sameSite: 'Lax',
  //   maxAge: 600, // 10 minutes expiry
  //   path: '/api/setup'
  // });
  //
  // 5. Build authorization URL with state token (unsigned)
  // const params = new URLSearchParams({
  //   client_id: clientId,
  //   redirect_uri: redirectUri,
  //   response_type: 'code',
  //   scope: 'https://www.googleapis.com/auth/spreadsheets https://www.googleapis.com/auth/drive.readonly',
  //   access_type: 'offline',
  //   prompt: 'consent',
  //   state: stateToken
  // });
  //
  // 6. Return redirect URL to client
  // return c.json({ authUrl: `https://accounts.google.com/o/oauth2/v2/auth?${params}` });
});

/**
 * GET /api/setup/google-callback - Handle OAuth2 callback
 *
 * Receives authorization code from Google
 * Exchanges code for access token and refresh token
 *
 * CSRF Protection: Validates signed cookie against state parameter
 */
setup.get('/google-callback', async (c) => {
  // Implementation:
  // 1. Extract state parameter from query string
  // const stateFromQuery = c.req.query('state');
  // if (!stateFromQuery) {
  //   return c.json({ error: 'Missing state parameter' }, 400);
  // }
  //
  // 2. Extract signed state from cookie
  // const signedStateFromCookie = c.req.cookie('oauth_state');
  // if (!signedStateFromCookie) {
  //   return c.json({ error: 'Missing state cookie' }, 400);
  // }
  //
  // 3. Delete cookie immediately (single-use)
  // c.cookie('oauth_state', '', { maxAge: 0, path: '/api/setup' });
  //
  // 4. Verify signature and extract state token from cookie
  // const [cookieState, cookieSignatureB64] = signedStateFromCookie.split('.');
  // const secret = c.env.OAUTH_STATE_SECRET;
  // const encoder = new TextEncoder();
  // const key = await crypto.subtle.importKey(
  //   'raw',
  //   encoder.encode(secret),
  //   { name: 'HMAC', hash: 'SHA-256' },
  //   false,
  //   ['verify']
  // );
  // const cookieSignature = Uint8Array.from(atob(cookieSignatureB64), c => c.charCodeAt(0));
  // const isValid = await crypto.subtle.verify(
  //   'HMAC',
  //   key,
  //   cookieSignature,
  //   encoder.encode(cookieState)
  // );
  // if (!isValid) {
  //   return c.json({ error: 'Invalid state signature' }, 400);
  // }
  //
  // 5. Compare state token from cookie with query parameter
  // if (cookieState !== stateFromQuery) {
  //   return c.json({ error: 'State mismatch - possible CSRF attack' }, 400);
  // }
  //
  // 6. Retrieve google_client_id, google_client_secret from config table
  // 7. Exchange authorization code for tokens
  // 8. Store tokens in D1 config table (google_access_token, google_refresh_token)
  // 9. Redirect to setup page with success status
});

export default setup;
```

### 5. シート一覧取得エンドポイント

```typescript
/**
 * GET /api/setup/sheets - Get available sheets
 *
 * Returns list of accessible Google Sheets from authenticated account
 */
setup.get('/sheets', async (c) => {
  // Implementation:
  // 1. Retrieve access token from config table
  // 2. Call Google Drive API to list spreadsheets
  // 3. Return sheet metadata (id, name, url)
});
```

### 6. シート初期化エンドポイント

```typescript
/**
 * POST /api/setup/initialize-sheet - Initialize required sheets
 *
 * Request body:
 * {
 *   "sheetId": "spreadsheet_id"
 * }
 *
 * Creates required sheets (_Users, _Roles, _Files) with headers
 * Returns progress updates via Server-Sent Events (SSE)
 */
setup.post('/initialize-sheet', async (c) => {
  // Implementation:
  // 1. Retrieve access token from config table
  // 2. Get spreadsheet metadata to check existing sheets
  // 3. Create _Users sheet if not exists:
  //    - Add sheet with title "_Users"
  //    - Set header row: id, email, name, password_hash, role, created_at, updated_at
  //    - Freeze header row
  // 4. Create _Roles sheet if not exists:
  //    - Add sheet with title "_Roles"
  //    - Set header row: id, name, permissions, created_at, updated_at
  //    - Freeze header row
  // 5. Create _Files sheet if not exists:
  //    - Add sheet with title "_Files"
  //    - Set header row: id, name, path, size, mime_type, uploaded_by, created_at
  //    - Freeze header row
  // 6. Return completion status with created sheets list
});
```

### 7. 初期設定完了エンドポイント

```typescript
/**
 * POST /api/setup/complete - Complete initial setup
 *
 * Request body:
 * {
 *   "sheetId": "spreadsheet_id",
 *   "sheetName": "Sheet名",
 *   "fileStorage": {
 *     "type": "google_drive" | "r2",
 *     "googleDriveFolderId"?: "folder_id",
 *     "r2Config"?: {
 *       "bucketName": "bucket-name",
 *       "accountId": "account-id",
 *       "accessKeyId": "access-key",
 *       "secretAccessKey": "secret"
 *     }
 *   },
 *   "adminUser": {
 *     "userId": "admin",
 *     "password": "secure-password"
 *   },
 *   "masterKey": "generated-or-custom-key"
 * }
 *
 * Completes all initial setup:
 * - Sheet configuration
 * - File storage settings
 * - Initial admin user
 * - Master key
 */
setup.post('/complete', async (c) => {
  // Implementation:
  // 1. Validate sheet ID and fetch metadata
  // 2. Validate sheet structure (_Users, _Roles sheets)
  // 3. Validate file storage configuration
  // 4. Encrypt and save file storage credentials
  // 5. Create initial admin user in _Users sheet
  // 6. Encrypt and save master key
  // 7. Save all configuration to config table:
  //    - selected_sheet_id
  //    - selected_sheet_name
  //    - file_storage_type
  //    - google_drive_folder_id (if applicable)
  //    - r2_* (if applicable, encrypted)
  //    - master_key (encrypted)
  // 8. Mark setup as completed
  // 9. Return success response
});
```

### 7. Google API クライアント設定

```typescript
// src/services/google-auth.service.ts
import type { Env } from '../types/env';
import type { TokenResponse } from '../types/google';
import { ConfigRepository } from '../db/config.repository';

/**
 * Google OAuth2 Service
 *
 * Handles authentication and token management using fetch-based REST API
 * Compatible with Cloudflare Workers runtime
 *
 * Credentials are stored in D1 config table, not environment variables
 *
 * Required OAuth Scopes:
 * - https://www.googleapis.com/auth/spreadsheets.readonly
 * - https://www.googleapis.com/auth/drive.readonly
 */
export class GoogleAuthService {
  private configRepo: ConfigRepository;

  constructor(env: Env) {
    // Implementation:
    // Initialize config repository to retrieve credentials from D1
    // this.configRepo = new ConfigRepository(env);
  }

  /**
   * Get Google credentials from config table
   */
  private async getCredentials(): Promise<{
    clientId: string;
    clientSecret: string;
    redirectUri: string;
  }> {
    // Implementation:
    // const clientId = await this.configRepo.get('google_client_id');
    // const clientSecret = await this.configRepo.getDecrypted('google_client_secret');
    // const redirectUri = await this.configRepo.get('google_redirect_uri');
    //
    // if (!clientId || !clientSecret || !redirectUri) {
    //   throw new Error('Google credentials not configured');
    // }
    //
    // return { clientId, clientSecret, redirectUri };
  }

  /**
   * Generate authorization URL
   *
   * Builds OAuth2 authorization URL with required scopes
   * Retrieves credentials from config table
   */
  async getAuthUrl(state: string): Promise<string> {
    // Implementation:
    // const { clientId, redirectUri } = await this.getCredentials();
    //
    // const params = new URLSearchParams({
    //   client_id: clientId,
    //   redirect_uri: redirectUri,
    //   response_type: 'code',
    //   scope: 'https://www.googleapis.com/auth/spreadsheets.readonly https://www.googleapis.com/auth/drive.readonly',
    //   access_type: 'offline',
    //   prompt: 'consent',
    //   state: state
    // });
    // return `https://accounts.google.com/o/oauth2/v2/auth?${params}`;
  }

  /**
   * Exchange authorization code for tokens
   *
   * Uses Google OAuth2 token endpoint via fetch
   * Retrieves credentials from config table
   */
  async getTokens(code: string): Promise<TokenResponse> {
    // Implementation:
    // const { clientId, clientSecret, redirectUri } = await this.getCredentials();
    //
    // const response = await fetch('https://oauth2.googleapis.com/token', {
    //   method: 'POST',
    //   headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    //   body: new URLSearchParams({
    //     code,
    //     client_id: clientId,
    //     client_secret: clientSecret,
    //     redirect_uri: redirectUri,
    //     grant_type: 'authorization_code'
    //   })
    // });
    //
    // if (!response.ok) {
    //   throw new Error(`Token exchange failed: ${response.statusText}`);
    // }
    //
    // return await response.json();
  }

  /**
   * Refresh access token
   *
   * Uses Google OAuth2 token endpoint to refresh expired token
   * Retrieves credentials from config table
   */
  async refreshAccessToken(refreshToken: string): Promise<string> {
    // Implementation:
    // const { clientId, clientSecret } = await this.getCredentials();
    //
    // const response = await fetch('https://oauth2.googleapis.com/token', {
    //   method: 'POST',
    //   headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    //   body: new URLSearchParams({
    //     refresh_token: refreshToken,
    //     client_id: clientId,
    //     client_secret: clientSecret,
    //     grant_type: 'refresh_token'
    //   })
    // });
    //
    // if (!response.ok) {
    //   throw new Error(`Token refresh failed: ${response.statusText}`);
    // }
    //
    // const data = await response.json();
    // return data.access_token;
  }
}
```

```typescript
// src/services/google-sheets.service.ts
import type { SpreadsheetMetadata, SpreadsheetInfo, ValidationResult } from '../types/google';

/**
 * Google Sheets Service
 *
 * Handles Google Sheets API operations using fetch-based REST API
 * Compatible with Cloudflare Workers runtime
 *
 * Uses Google Drive API v3 and Google Sheets API v4
 */
export class GoogleSheetsService {
  private accessToken: string;

  constructor(accessToken: string) {
    // Implementation: Store access token for Authorization header
    // this.accessToken = accessToken;
  }

  /**
   * List available spreadsheets
   *
   * Calls Google Drive API v3 files endpoint
   * Filters by mimeType for Google Sheets
   */
  async listSpreadsheets(): Promise<SpreadsheetMetadata[]> {
    // Implementation:
    // const params = new URLSearchParams({
    //   q: "mimeType='application/vnd.google-apps.spreadsheet'",
    //   fields: 'files(id,name,webViewLink,createdTime,modifiedTime)',
    //   orderBy: 'modifiedTime desc',
    //   pageSize: '100'
    // });
    //
    // const response = await fetch(
    //   `https://www.googleapis.com/drive/v3/files?${params}`,
    //   {
    //     headers: {
    //       'Authorization': `Bearer ${this.accessToken}`,
    //       'Accept': 'application/json'
    //     }
    //   }
    // );
    //
    // if (!response.ok) {
    //   throw new Error(`Failed to list spreadsheets: ${response.statusText}`);
    // }
    //
    // const data = await response.json();
    // return data.files.map(file => ({
    //   id: file.id,
    //   name: file.name,
    //   url: file.webViewLink,
    //   createdTime: file.createdTime,
    //   modifiedTime: file.modifiedTime
    // }));
  }

  /**
   * Get spreadsheet metadata
   *
   * Calls Google Sheets API v4 spreadsheets.get endpoint
   * Includes sheet properties (title, index, rowCount, columnCount)
   */
  async getSpreadsheetMetadata(sheetId: string): Promise<SpreadsheetInfo> {
    // Implementation:
    // const params = new URLSearchParams({
    //   fields: 'spreadsheetId,properties.title,sheets(properties(sheetId,title,index,gridProperties))'
    // });
    //
    // const response = await fetch(
    //   `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}?${params}`,
    //   {
    //     headers: {
    //       'Authorization': `Bearer ${this.accessToken}`,
    //       'Accept': 'application/json'
    //     }
    //   }
    // );
    //
    // if (!response.ok) {
    //   throw new Error(`Failed to get spreadsheet metadata: ${response.statusText}`);
    // }
    //
    // const data = await response.json();
    // return {
    //   id: data.spreadsheetId,
    //   name: data.properties.title,
    //   sheets: data.sheets.map(sheet => ({
    //     sheetId: sheet.properties.sheetId,
    //     title: sheet.properties.title,
    //     index: sheet.properties.index,
    //     rowCount: sheet.properties.gridProperties.rowCount,
    //     columnCount: sheet.properties.gridProperties.columnCount
    //   }))
    // };
  }

  /**
   * Create required sheet with headers
   *
   * Creates a new sheet in the spreadsheet with specified title and headers
   * Uses Google Sheets API v4 batchUpdate endpoint
   */
  async createSheetWithHeaders(
    sheetId: string,
    sheetTitle: string,
    headers: string[]
  ): Promise<void> {
    // Implementation:
    // 1. Create new sheet
    // const createRequest = {
    //   requests: [
    //     {
    //       addSheet: {
    //         properties: {
    //           title: sheetTitle,
    //           gridProperties: {
    //             rowCount: 1000,
    //             columnCount: headers.length,
    //             frozenRowCount: 1
    //           }
    //         }
    //       }
    //     }
    //   ]
    // };
    //
    // const createResponse = await fetch(
    //   `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}:batchUpdate`,
    //   {
    //     method: 'POST',
    //     headers: {
    //       'Authorization': `Bearer ${this.accessToken}`,
    //       'Content-Type': 'application/json'
    //     },
    //     body: JSON.stringify(createRequest)
    //   }
    // );
    //
    // if (!createResponse.ok) {
    //   throw new Error(`Failed to create sheet: ${createResponse.statusText}`);
    // }
    //
    // 2. Set header values
    // const updateResponse = await fetch(
    //   `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${sheetTitle}!A1:${String.fromCharCode(64 + headers.length)}1?valueInputOption=RAW`,
    //   {
    //     method: 'PUT',
    //     headers: {
    //       'Authorization': `Bearer ${this.accessToken}`,
    //       'Content-Type': 'application/json'
    //     },
    //     body: JSON.stringify({
    //       values: [headers]
    //     })
    //   }
    // );
    //
    // if (!updateResponse.ok) {
    //   throw new Error(`Failed to set headers: ${updateResponse.statusText}`);
    // }
    //
    // 3. Format header row (bold, background color)
    // const formatRequest = {
    //   requests: [
    //     {
    //       repeatCell: {
    //         range: {
    //           sheetId: (await this.getSheetIdByTitle(sheetId, sheetTitle)),
    //           startRowIndex: 0,
    //           endRowIndex: 1
    //         },
    //         cell: {
    //           userEnteredFormat: {
    //             backgroundColor: { red: 0.9, green: 0.9, blue: 0.9 },
    //             textFormat: { bold: true }
    //           }
    //         },
    //         fields: 'userEnteredFormat(backgroundColor,textFormat)'
    //       }
    //     }
    //   ]
    // };
    //
    // await fetch(
    //   `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}:batchUpdate`,
    //   {
    //     method: 'POST',
    //     headers: {
    //       'Authorization': `Bearer ${this.accessToken}`,
    //       'Content-Type': 'application/json'
    //     },
    //     body: JSON.stringify(formatRequest)
    //   }
    // );
  }

  /**
   * Check if sheet exists
   */
  async sheetExists(sheetId: string, sheetTitle: string): Promise<boolean> {
    // Implementation:
    // const metadata = await this.getSpreadsheetMetadata(sheetId);
    // return metadata.sheets.some(s => s.title === sheetTitle);
  }

  /**
   * Validate sheet structure
   *
   * Checks for required sheets (_Users, _Roles, _Files) and validates column structure
   * Fetches first row to verify column headers
   */
  async validateSheetStructure(sheetId: string): Promise<ValidationResult> {
    // Implementation:
    // 1. Get spreadsheet metadata
    // const metadata = await this.getSpreadsheetMetadata(sheetId);
    //
    // 2. Check for _Users, _Roles, _Files sheets
    // const usersSheet = metadata.sheets.find(s => s.title === '_Users');
    // const rolesSheet = metadata.sheets.find(s => s.title === '_Roles');
    // const filesSheet = metadata.sheets.find(s => s.title === '_Files');
    //
    // const errors: string[] = [];
    // const warnings: string[] = [];
    //
    // if (!usersSheet) {
    //   errors.push('Required sheet "_Users" not found');
    // }
    // if (!rolesSheet) {
    //   errors.push('Required sheet "_Roles" not found');
    // }
    // if (!filesSheet) {
    //   errors.push('Required sheet "_Files" not found');
    // }
    //
    // 3. Validate _Users columns (if exists)
    // if (usersSheet) {
    //   const response = await fetch(
    //     `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/_Users!A1:Z1`,
    //     {
    //       headers: {
    //         'Authorization': `Bearer ${this.accessToken}`,
    //         'Accept': 'application/json'
    //       }
    //     }
    //   );
    //   const data = await response.json();
    //   const columns = data.values?.[0] || [];
    //
    //   // Check for required columns
    //   const requiredColumns = ['id', 'email', 'name', 'role'];
    //   for (const col of requiredColumns) {
    //     if (!columns.includes(col)) {
    //       errors.push(`_Users sheet missing required column: ${col}`);
    //     }
    //   }
    // }
    //
    // 4. Validate _Roles columns (if exists)
    // Similar validation for _Roles sheet
    //
    // return {
    //   valid: errors.length === 0,
    //   errors,
    //   warnings,
    //   hasUsersSheet: !!usersSheet,
    //   hasRolesSheet: !!rolesSheet
    // };
  }
}
```

### 8. 設定保存機能（D1 configテーブル）

```typescript
// src/db/config.repository.ts
import { createDbClient } from './client';
import { config } from './schema';
import type { Env } from '../types/env';

/**
 * Configuration Repository
 *
 * Manages system configuration in D1 config table
 */
export class ConfigRepository {
  private db;

  constructor(env: Env) {
    this.db = createDbClient(env);
  }

  /**
   * Save Google OAuth2 credentials (Client ID, Secret, Redirect URI)
   */
  async saveGoogleCredentials(credentials: {
    clientId: string;
    clientSecret: string;
    redirectUri: string;
  }): Promise<void> {
    // Implementation:
    // Encrypt client secret before storage
    // INSERT or UPDATE config entries:
    // - google_client_id
    // - google_client_secret (encrypted)
    // - google_redirect_uri
  }

  /**
   * Get configuration value
   */
  async get(key: string): Promise<string | null> {
    // Implementation: Retrieve config value by key
  }

  /**
   * Get and decrypt configuration value
   */
  async getDecrypted(key: string): Promise<string | null> {
    // Implementation: Retrieve and decrypt config value
  }

  /**
   * Save file storage configuration
   */
  async saveFileStorageConfig(config: {
    type: 'google_drive' | 'r2';
    googleDriveFolderId?: string;
    r2Config?: {
      bucketName: string;
      accountId: string;
      accessKeyId: string;
      secretAccessKey: string;
    };
  }): Promise<void> {
    // Implementation:
    // Save file_storage_type
    // If google_drive: save google_drive_folder_id
    // If r2: encrypt and save r2_bucket_name, r2_account_id,
    //        r2_access_key_id, r2_secret_access_key
  }

  /**
   * Save master key (encrypted)
   */
  async saveMasterKey(masterKey: string): Promise<void> {
    // Implementation:
    // Encrypt and save master_key to config table
  }

  /**
   * Save selected sheet configuration
   */
  async saveSheetConfig(sheetId: string, sheetName: string): Promise<void> {
    // Implementation:
    // Save selected_sheet_id and selected_sheet_name
  }

  /**
   * Mark setup as completed
   */
  async markSetupCompleted(): Promise<void> {
    // Implementation:
    // Save setup_completed = true
  }

  /**
   * Save Google OAuth tokens
   */
  async saveGoogleTokens(tokens: {
    accessToken: string;
    refreshToken: string;
    expiresAt: Date;
  }): Promise<void> {
    // Implementation:
    // INSERT or UPDATE config entries
    // - google_access_token
    // - google_refresh_token
    // - google_token_expires_at
  }

  /**
   * Get Google access token
   */
  async getGoogleAccessToken(): Promise<string | null> {
    // Implementation: Retrieve access token from config
  }

  /**
   * Check if initial setup is complete
   */
  async isSetupComplete(): Promise<boolean> {
    // Implementation:
    // Check if setup_completed flag is true
  }
}
```

### 9. 型定義

```typescript
// src/types/google.ts

/**
 * Google OAuth2 token response
 */
export interface TokenResponse {
  access_token: string;
  refresh_token: string;
  expires_in: number;
  token_type: string;
  scope: string;
}

/**
 * Spreadsheet metadata
 */
export interface SpreadsheetMetadata {
  id: string;
  name: string;
  url: string;
  createdTime: string;
  modifiedTime: string;
}

/**
 * Spreadsheet detailed information
 */
export interface SpreadsheetInfo {
  id: string;
  name: string;
  sheets: SheetInfo[];
}

/**
 * Individual sheet information
 */
export interface SheetInfo {
  sheetId: number;
  title: string;
  index: number;
  rowCount: number;
  columnCount: number;
}

/**
 * Sheet structure validation result
 */
export interface ValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
  hasUsersSheet: boolean;
  hasRolesSheet: boolean;
  hasFilesSheet: boolean;
}

/**
 * Sheet initialization progress
 */
export interface SheetInitProgress {
  step: 'users' | 'roles' | 'files' | 'complete';
  message: string;
  completed: boolean;
}

/**
 * Sheet initialization result
 */
export interface SheetInitResult {
  success: boolean;
  createdSheets: string[];
  errors: string[];
}

/**
 * File storage configuration
 */
export interface FileStorageConfig {
  type: 'google_drive' | 'r2';
  googleDriveFolderId?: string;
  r2Config?: R2Config;
}

/**
 * R2 storage configuration
 */
export interface R2Config {
  bucketName: string;
  accountId: string;
  accessKeyId: string;
  secretAccessKey: string;
}

/**
 * Initial admin user configuration
 */
export interface AdminUserConfig {
  userId: string;
  password: string;
}

/**
 * Complete setup request
 */
export interface CompleteSetupRequest {
  sheetId: string;
  sheetName: string;
  fileStorage: FileStorageConfig;
  adminUser: AdminUserConfig;
  masterKey: string;
}
```

## セキュリティ要件

### OAuth2セキュリティ

#### 1. State Parameter（CSRF対策）
**実装方式: 署名付きCookie**

- **State生成**: `crypto.randomUUID()`で暗号学的に安全なランダムトークンを生成
- **署名**: HMAC-SHA256でトークンに署名（秘密鍵は環境変数`OAUTH_STATE_SECRET`）
- **保存**: 署名付きトークン（`token.signature`形式）をHttpOnly/Secure/SameSite=Lax Cookieに保存
- **有効期限**: Cookie maxAge=600（10分間）で自動失効
- **検証**:
  1. コールバック時にCookieから署名付きトークンを取得
  2. HMAC-SHA256で署名を検証
  3. クエリパラメータのstateと一致確認
  4. Cookie即座に削除（使い捨て）
- **利点**:
  - D1/KVへの書き込み不要（状態管理なし）
  - Workers Unboundプランでも追加コストなし
  - Web Crypto API標準機能のみ使用（依存なし）

#### 2. PKCE
- 可能であればPKCE (Proof Key for Code Exchange) を実装
- Code Verifier/Challenge生成にWeb Crypto APIを使用

#### 3. Token Storage
- Refresh tokenは暗号化してD1に保存
- Access tokenも暗号化推奨（短期間だが漏洩リスク低減）

#### 4. Scope Minimization
- 初期設定時: 書き込み権限必須（シート作成のため）
  - `https://www.googleapis.com/auth/spreadsheets` - Sheets書き込み
  - `https://www.googleapis.com/auth/drive.readonly` - Drive読み取り専用（シート一覧取得用）
- 通常運用時: 読み取り専用トークンへの切り替えも検討可能

### API Security
1. **Rate Limiting**: 認証エンドポイントにレート制限適用
2. **Input Validation**: すべてのユーザー入力を検証
3. **Error Handling**: 詳細なエラー情報を外部に漏らさない
4. **Master Key**: ACLバイパス用マスターキーは暗号化して保存
5. **Admin Password**: 初期管理者パスワードはハッシュ化して保存
6. **R2 Credentials**: R2認証情報は暗号化して保存

## エラーハンドリング

### 認証エラー
- OAuth2認証失敗時の明確なエラーメッセージ
- トークン期限切れ時の自動リフレッシュ
- リフレッシュトークン無効時の再認証フロー

### シート選択エラー
- シートアクセス権限不足
- 必須シート(_Users, _Roles, _Files)の欠落
- シート構造の不正

### シート初期化エラー
- Google Sheets API書き込み権限不足
- シート作成失敗（APIエラー）
- ヘッダー行設定失敗
- 既存シート名の重複

### 初期設定エラー
- ファイル保存先設定の検証失敗
- R2認証情報の不正
- 管理者パスワードの要件違反（例: 8文字未満）
- Google Sheetsへの管理者ユーザー書き込み失敗

### データベースエラー
- 設定保存失敗時のロールバック
- 接続エラー時のリトライ

## テスト要件

### 統合テスト
```typescript
// tests/integration/setup/google-auth.test.ts
describe('Google OAuth2 Integration', () => {
  it('should generate valid authorization URL', async () => {
    // Implementation: Test authorization URL generation
  });

  it('should exchange code for tokens', async () => {
    // Implementation: Test token exchange (with real Google API)
  });

  it('should save tokens to config table', async () => {
    // Implementation: Test token persistence
  });
});
```

### E2Eテスト (Playwright)
```typescript
// tests/e2e/setup/initial-setup.spec.ts
test('complete initial setup flow', async ({ page }) => {
  // Implementation:
  // 1. Navigate to /setup
  // 2. Enter Google credentials (Client ID, Secret, Redirect URI)
  // 3. Click "認証情報を保存してGoogleに接続"
  // 4. Complete Google OAuth flow
  // 5. Select a sheet from dropdown
  // 6. Wait for sheet initialization progress:
  //    - Verify "_Usersシート作成中..." appears
  //    - Verify "_Rolesシート作成中..." appears
  //    - Verify "_Filesシート作成中..." appears
  //    - Verify all complete with checkmarks
  // 7. Choose file storage (Google Drive or R2)
  // 8. Enter initial admin user credentials
  // 9. Generate or enter master key
  // 10. Click "設定を完了"
  // 11. Verify redirect to dashboard
});
```

## 完了条件

1. ✅ 初期設定画面（3ステップ + シート初期化）が表示される
2. ✅ Google認証情報フォーム入力・保存が機能する
3. ✅ Google OAuth2フローが正常に完了
4. ✅ 認証後、自動的にシート選択画面に遷移
5. ✅ 利用可能なシート一覧が表示される
6. ✅ シート選択後、自動的にシート初期化が開始される
7. ✅ シート初期化プログレスインジケーターが表示される
8. ✅ _Users, _Roles, _Filesシートが自動作成される
9. ✅ 各シートにヘッダー行が設定される（frozenRowCount=1）
10. ✅ シート初期化完了後、ファイル保存先・初期管理者設定画面に遷移
11. ✅ ファイル保存先（Google Drive or R2）を選択・入力できる
12. ✅ 初期管理者ID・パスワードを入力できる
13. ✅ マスターキーを生成または入力できる
14. ✅ すべての設定がD1 configテーブルに保存される
15. ✅ 初期管理者が_Usersシートに作成される
16. ✅ 画面での初期設定が実環境で完全動作
17. ✅ 本番環境にデプロイして動作確認

## 実装上の注意

### Cloudflare Workers互換性
- **fetch API使用**: すべてのHTTP通信はfetchを使用
- **Node.js専用モジュール禁止**: googleapis等のNode.js専用パッケージは使用不可
- **REST API直接呼び出し**: Google APIs はREST endpoint経由で直接呼び出し
- **JSON解析**: すべてのレスポンスはJSON.parse()またはresponse.json()で処理
- **エラーハンドリング**: 非2xxレスポンスは明示的にエラーとして処理

### Google Sheets API書き込み権限
- **OAuth Scope**: シート作成には書き込み権限が必要
  - 読み取り専用: `https://www.googleapis.com/auth/spreadsheets.readonly`
  - **書き込み必須**: `https://www.googleapis.com/auth/spreadsheets` (シート初期化で使用)
- **スコープ選択**: 初期設定時は書き込み権限で認証し、通常運用時は読み取り専用トークンを使用する設計も検討可能

### シート初期化の設計
- **べき等性**: 既に存在するシートはスキップし、エラーとしない
- **トランザクション性**: 一部失敗時も、成功したシートは維持（ロールバック不要）
- **プログレス表示**: フロントエンドでリアルタイムに進行状況を表示
- **エラーリカバリ**: 失敗したシートのみを再作成できる仕組み

### OAuth State検証の実装詳細

**署名付きCookieフロー**:

```typescript
// State生成とCookie設定（/api/setup/google-auth）
const stateToken = crypto.randomUUID();
const secret = c.env.OAUTH_STATE_SECRET;
const key = await crypto.subtle.importKey(
  'raw',
  new TextEncoder().encode(secret),
  { name: 'HMAC', hash: 'SHA-256' },
  false,
  ['sign']
);
const signature = await crypto.subtle.sign(
  'HMAC',
  key,
  new TextEncoder().encode(stateToken)
);
const signedState = `${stateToken}.${btoa(String.fromCharCode(...new Uint8Array(signature)))}`;

c.cookie('oauth_state', signedState, {
  httpOnly: true,
  secure: true,
  sameSite: 'Lax',
  maxAge: 600,
  path: '/api/setup'
});

// State検証（/api/setup/google-callback）
const stateFromQuery = c.req.query('state');
const signedStateFromCookie = c.req.cookie('oauth_state');
c.cookie('oauth_state', '', { maxAge: 0, path: '/api/setup' }); // 即座に削除

const [cookieState, cookieSignatureB64] = signedStateFromCookie.split('.');
const key = await crypto.subtle.importKey(
  'raw',
  new TextEncoder().encode(c.env.OAUTH_STATE_SECRET),
  { name: 'HMAC', hash: 'SHA-256' },
  false,
  ['verify']
);
const cookieSignature = Uint8Array.from(atob(cookieSignatureB64), c => c.charCodeAt(0));
const isValid = await crypto.subtle.verify('HMAC', key, cookieSignature, new TextEncoder().encode(cookieState));

if (!isValid || cookieState !== stateFromQuery) {
  throw new Error('State verification failed - CSRF attack detected');
}
```

**代替案（検討不要だが参考）**:
- D1保存方式: state tokenをハッシュ化してD1に保存（書き込みコスト、クリーンアップ処理必要）
- KV保存方式: state tokenをKVに保存（KV追加コスト、Workers Unboundプラン必要）

**採用理由**: 署名付きCookieは状態管理不要で、追加コストなし、Web Crypto API標準機能のみで実装可能

## 環境設定チェックリスト

### Google Cloud Console設定（ユーザーが実施）
- [ ] Google Cloud Console プロジェクト作成
- [ ] OAuth 2.0 クライアント ID 作成（開発環境・本番環境）
- [ ] 承認済みリダイレクトURI 設定
  - 開発: `http://localhost:8787/api/setup/google-callback`
  - 本番: `https://your-app.workers.dev/api/setup/google-callback`
- [ ] Google Sheets API 有効化
- [ ] Google Drive API 有効化

### アプリケーション設定（初期設定画面で実施）
- [ ] 初期設定画面でGoogle Client ID入力
- [ ] 初期設定画面でGoogle Client Secret入力
- [ ] 初期設定画面でRedirect URI設定（自動生成も可能）
- [ ] D1 configテーブルに認証情報が暗号化保存されることを確認

### Cloudflare Workers環境変数
- [ ] `OAUTH_STATE_SECRET` - OAuth state署名用の秘密鍵（32文字以上のランダム文字列）
  - 開発: `wrangler.toml` の `[vars]` セクションに設定
  - 本番: `wrangler secret put OAUTH_STATE_SECRET` で設定
  - 生成例: `openssl rand -base64 32`

## 参考リソース

- [Google OAuth 2.0 Documentation](https://developers.google.com/identity/protocols/oauth2)
- [Google OAuth 2.0 REST API](https://developers.google.com/identity/protocols/oauth2/web-server)
- [Google Sheets API v4 REST Reference](https://developers.google.com/sheets/api/reference/rest)
- [Google Drive API v3 REST Reference](https://developers.google.com/drive/api/v3/reference)
